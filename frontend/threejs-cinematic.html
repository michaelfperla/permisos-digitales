<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Permisos Digitales - 3D Cinematic Experience</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #000;
            overflow: hidden;
        }
        
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .text-overlay {
            position: absolute;
            color: white;
            font-weight: bold;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.8s cubic-bezier(0.23, 1, 0.32, 1);
        }
        
        .text-overlay.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        #scene1-text {
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 48px;
            text-shadow: 0 0 20px rgba(0,0,0,0.8);
        }
        
        #logo-text {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 72px;
            letter-spacing: 5px;
            text-align: center;
        }
        
        .cta-button {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            padding: 20px 60px;
            background: rgba(181, 56, 77, 0.9);
            color: white;
            border: none;
            border-radius: 50px;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            opacity: 0;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            pointer-events: all;
        }
        
        .cta-button.visible {
            opacity: 1;
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.05); }
        }
        
        .cta-button:hover {
            background: rgba(181, 56, 77, 1);
            transform: translateX(-50%) scale(1.1);
        }
        
        .progress-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            z-index: 100;
        }
        
        .progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #B5384D 0%, #FFD700 100%);
            transition: width 0.1s linear;
        }
        
        .skip-button {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            z-index: 100;
            transition: all 0.3s ease;
        }
        
        .skip-button:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 1000;
        }
        
        .glitch {
            animation: glitch 0.3s ease-in-out;
        }
        
        @keyframes glitch {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            20% { transform: translateX(-52%) translateY(-2px); }
            40% { transform: translateX(-48%) translateY(2px); }
            60% { transform: translateX(-51%) translateY(-1px); }
            80% { transform: translateX(-49%) translateY(1px); }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>
<body>
    <div id="loading">Cargando experiencia 3D...</div>
    <canvas id="canvas"></canvas>
    
    <div class="overlay">
        <div id="scene1-text" class="text-overlay">Horas perdidas...</div>
        <div id="logo-text" class="text-overlay">
            PERMISOS DIGITALES<br>
            <span style="font-size: 32px; opacity: 0.8;">La evolución del trámite</span>
        </div>
        <button class="cta-button" onclick="window.location.href='#'">
            OBTÉN TU PERMISO AHORA
        </button>
    </div>
    
    <div class="progress-bar">
        <div class="progress-fill"></div>
    </div>
    
    <button class="skip-button" onclick="skipToEnd()">Saltar →</button>
    
    <script>
        // Three.js setup
        let scene, camera, renderer, composer;
        let clock = new THREE.Clock();
        let mixer;
        
        // Objects
        let queuePeople = [];
        let officeClock;
        let walls = [];
        let particles = [];
        let permitCard;
        let floatingUI = [];
        let logo;
        
        // Timeline
        let currentTime = 0;
        const totalDuration = 15; // seconds
        let isPlaying = true;
        
        // Initialize
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 10, 100);
            
            // Camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 5, 10);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('canvas'),
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            
            // Hide loading
            document.getElementById('loading').style.display = 'none';
            
            // Start animation
            createScene1();
            animate();
        }
        
        // SCENE 1: The Old Way (0-3s)
        function createScene1() {
            // Harsh lighting
            const light = new THREE.DirectionalLight(0xffffff, 0.5);
            light.position.set(0, 10, 0);
            scene.add(light);
            
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            // Create office environment
            createOfficeWalls();
            createQueuePeople();
            createOfficeClock();
            
            // Show text
            setTimeout(() => {
                document.getElementById('scene1-text').classList.add('visible');
                document.getElementById('scene1-text').classList.add('glitch');
            }, 500);
        }
        
        function createOfficeWalls() {
            const wallGeometry = new THREE.BoxGeometry(20, 10, 0.5);
            const wallMaterial = new THREE.MeshPhongMaterial({
                color: 0x666666,
                emissive: 0x111111
            });
            
            // Back wall
            const backWall = new THREE.Mesh(wallGeometry, wallMaterial);
            backWall.position.z = -5;
            scene.add(backWall);
            walls.push(backWall);
            
            // Side walls
            const sideWallGeometry = new THREE.BoxGeometry(0.5, 10, 10);
            const leftWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
            leftWall.position.x = -10;
            scene.add(leftWall);
            walls.push(leftWall);
            
            const rightWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
            rightWall.position.x = 10;
            scene.add(rightWall);
            walls.push(rightWall);
            
            // Floor
            const floorGeometry = new THREE.PlaneGeometry(20, 10);
            const floorMaterial = new THREE.MeshPhongMaterial({
                color: 0x444444,
                side: THREE.DoubleSide
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -2;
            scene.add(floor);
        }
        
        function createQueuePeople() {
            const personGeometry = new THREE.CylinderGeometry(0.3, 0.3, 2);
            const headGeometry = new THREE.SphereGeometry(0.4);
            
            for (let i = 0; i < 8; i++) {
                const group = new THREE.Group();
                
                // Body
                const bodyMaterial = new THREE.MeshPhongMaterial({
                    color: 0x333333,
                    emissive: 0x111111
                });
                const body = new THREE.Mesh(personGeometry, bodyMaterial);
                group.add(body);
                
                // Head
                const head = new THREE.Mesh(headGeometry, bodyMaterial);
                head.position.y = 1.2;
                group.add(head);
                
                // Position in queue
                group.position.x = (i % 4) * 2 - 3;
                group.position.z = Math.floor(i / 4) * 2 - 2;
                group.position.y = 0;
                
                // Sad swaying animation
                group.userData.offset = Math.random() * Math.PI * 2;
                
                queuePeople.push(group);
                scene.add(group);
            }
        }
        
        function createOfficeClock() {
            const clockGroup = new THREE.Group();
            
            // Clock face
            const clockGeometry = new THREE.CircleGeometry(1, 32);
            const clockMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                emissive: 0xffffff
            });
            const clockFace = new THREE.Mesh(clockGeometry, clockMaterial);
            clockGroup.add(clockFace);
            
            // Clock hands
            const handGeometry = new THREE.BoxGeometry(0.05, 0.8, 0.1);
            const handMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            
            const hourHand = new THREE.Mesh(handGeometry, handMaterial);
            hourHand.position.y = 0.4;
            clockGroup.add(hourHand);
            
            const minuteHand = new THREE.Mesh(
                new THREE.BoxGeometry(0.05, 1, 0.1),
                handMaterial
            );
            minuteHand.position.y = 0.5;
            clockGroup.add(minuteHand);
            
            clockGroup.position.set(0, 3, -4.9);
            clockGroup.userData.hourHand = hourHand;
            clockGroup.userData.minuteHand = minuteHand;
            
            officeClock = clockGroup;
            scene.add(clockGroup);
        }
        
        // SCENE 2: The Transformation (3-7s)
        function startTransformation() {
            document.getElementById('scene1-text').classList.remove('visible');
            
            // Explode walls into particles
            walls.forEach((wall, index) => {
                setTimeout(() => {
                    explodeObject(wall);
                }, index * 200);
            });
            
            // Create phone emerging
            setTimeout(createEmergingPhone, 1000);
            
            // Start digital rain
            setTimeout(createDigitalRain, 2000);
        }
        
        function explodeObject(object) {
            const geometry = object.geometry;
            const material = object.material;
            
            // Create particles from object
            for (let i = 0; i < 50; i++) {
                const particleGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
                const particleMaterial = new THREE.MeshPhongMaterial({
                    color: material.color,
                    emissive: 0x000000
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.copy(object.position);
                particle.position.x += (Math.random() - 0.5) * 5;
                particle.position.y += (Math.random() - 0.5) * 5;
                particle.position.z += (Math.random() - 0.5) * 5;
                
                particle.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.3,
                    Math.random() * 0.3,
                    (Math.random() - 0.5) * 0.3
                );
                
                particle.userData.rotationSpeed = new THREE.Vector3(
                    Math.random() * 0.1,
                    Math.random() * 0.1,
                    Math.random() * 0.1
                );
                
                particles.push(particle);
                scene.add(particle);
            }
            
            // Remove original object
            scene.remove(object);
        }
        
        function createEmergingPhone() {
            const phoneGroup = new THREE.Group();
            
            // Phone body
            const phoneGeometry = new THREE.BoxGeometry(2, 4, 0.2);
            const phoneMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x111111,
                metalness: 0.8,
                roughness: 0.2,
                clearcoat: 1,
                clearcoatRoughness: 0,
                emissive: 0x111111,
                emissiveIntensity: 0.2
            });
            
            const phone = new THREE.Mesh(phoneGeometry, phoneMaterial);
            phoneGroup.add(phone);
            
            // Screen
            const screenGeometry = new THREE.PlaneGeometry(1.8, 3.6);
            const screenMaterial = new THREE.MeshBasicMaterial({
                color: 0x00d4ff,
                emissive: 0x00d4ff,
                emissiveIntensity: 2
            });
            const screen = new THREE.Mesh(screenGeometry, screenMaterial);
            screen.position.z = 0.11;
            phoneGroup.add(screen);
            
            phoneGroup.position.y = -5;
            scene.add(phoneGroup);
            
            // Animate phone rising
            new TWEEN.Tween(phoneGroup.position)
                .to({ y: 0 }, 2000)
                .easing(TWEEN.Easing.Cubic.Out)
                .start();
            
            new TWEEN.Tween(phoneGroup.rotation)
                .to({ y: Math.PI * 2 }, 2000)
                .easing(TWEEN.Easing.Cubic.Out)
                .start();
        }
        
        function createDigitalRain() {
            const rainGeometry = new THREE.BoxGeometry(0.1, 0.5, 0.1);
            
            for (let i = 0; i < 100; i++) {
                const rainMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    emissive: 0x00ff00,
                    emissiveIntensity: 2,
                    transparent: true,
                    opacity: Math.random()
                });
                
                const rain = new THREE.Mesh(rainGeometry, rainMaterial);
                rain.position.set(
                    (Math.random() - 0.5) * 20,
                    Math.random() * 10 + 5,
                    (Math.random() - 0.5) * 10
                );
                
                rain.userData.velocity = Math.random() * 0.1 + 0.05;
                rain.userData.isRain = true;
                
                particles.push(rain);
                scene.add(rain);
            }
        }
        
        // SCENE 3: The New World (7-11s)
        function createNewWorld() {
            // Clean up old scene
            queuePeople.forEach(person => scene.remove(person));
            if (officeClock) scene.remove(officeClock);
            
            // Change lighting to golden
            scene.fog.color.setHex(0x000033);
            
            const warmLight = new THREE.DirectionalLight(0xffd700, 1);
            warmLight.position.set(5, 10, 5);
            warmLight.castShadow = true;
            scene.add(warmLight);
            
            const rimLight = new THREE.DirectionalLight(0xff6b6b, 0.5);
            rimLight.position.set(-5, 5, -5);
            scene.add(rimLight);
            
            // Create permit card
            createPermitCard();
            
            // Create floating UI
            createFloatingUI();
            
            // Create particle flow
            createParticleFlow();
            
            // Create grid floor
            createGridFloor();
        }
        
        function createPermitCard() {
            const cardGroup = new THREE.Group();
            
            // Card base
            const cardGeometry = new THREE.BoxGeometry(3.5, 2.2, 0.1);
            const cardMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xB5384D,
                metalness: 0.9,
                roughness: 0.1,
                clearcoat: 1,
                clearcoatRoughness: 0,
                emissive: 0xB5384D,
                emissiveIntensity: 0.2
            });
            
            const card = new THREE.Mesh(cardGeometry, cardMaterial);
            card.castShadow = true;
            card.receiveShadow = true;
            cardGroup.add(card);
            
            // Holographic overlay
            const holoGeometry = new THREE.PlaneGeometry(3.4, 2.1);
            const holoMaterial = new THREE.ShaderMaterial({
                transparent: true,
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    varying vec2 vUv;
                    void main() {
                        vec3 color = vec3(
                            sin(vUv.x * 10.0 + time) * 0.5 + 0.5,
                            sin(vUv.y * 10.0 + time * 1.3) * 0.5 + 0.5,
                            sin((vUv.x + vUv.y) * 10.0 + time * 0.7) * 0.5 + 0.5
                        );
                        gl_FragColor = vec4(color, 0.3);
                    }
                `
            });
            
            const holo = new THREE.Mesh(holoGeometry, holoMaterial);
            holo.position.z = 0.06;
            cardGroup.add(holo);
            
            cardGroup.position.set(0, 0, 0);
            permitCard = cardGroup;
            permitCard.userData.holoMaterial = holoMaterial;
            scene.add(permitCard);
        }
        
        function createFloatingUI() {
            const uiTexts = ['Login', 'Pago Seguro', '¡Éxito!'];
            const uiColors = [0x3b82f6, 0x10b981, 0xffd700];
            
            uiTexts.forEach((text, index) => {
                const uiGroup = new THREE.Group();
                
                // Glass panel
                const panelGeometry = new THREE.BoxGeometry(3, 1.5, 0.1);
                const panelMaterial = new THREE.MeshPhysicalMaterial({
                    color: 0xffffff,
                    metalness: 0,
                    roughness: 0,
                    transmission: 0.9,
                    thickness: 0.5,
                    emissive: uiColors[index],
                    emissiveIntensity: 0.1
                });
                
                const panel = new THREE.Mesh(panelGeometry, panelMaterial);
                uiGroup.add(panel);
                
                // Position around permit
                const angle = (index / 3) * Math.PI * 2;
                uiGroup.position.x = Math.cos(angle) * 5;
                uiGroup.position.z = Math.sin(angle) * 5;
                uiGroup.position.y = 1;
                
                uiGroup.lookAt(0, 1, 0);
                
                floatingUI.push(uiGroup);
                scene.add(uiGroup);
            });
        }
        
        function createParticleFlow() {
            const particleGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            
            for (let i = 0; i < 200; i++) {
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffd700,
                    emissive: 0xffd700,
                    emissiveIntensity: 2
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 10 + 5;
                particle.position.x = Math.cos(angle) * radius;
                particle.position.y = Math.random() * 5 - 2.5;
                particle.position.z = Math.sin(angle) * radius;
                
                particle.userData.angle = angle;
                particle.userData.radius = radius;
                particle.userData.speed = Math.random() * 0.02 + 0.01;
                particle.userData.isFlowParticle = true;
                
                particles.push(particle);
                scene.add(particle);
            }
        }
        
        function createGridFloor() {
            const gridHelper = new THREE.GridHelper(50, 50, 0x00d4ff, 0x00d4ff);
            gridHelper.material.opacity = 0.2;
            gridHelper.material.transparent = true;
            gridHelper.position.y = -2;
            scene.add(gridHelper);
        }
        
        // SCENE 4: The Reveal (11-15s)
        function createFinalReveal() {
            // Hide floating UI
            floatingUI.forEach(ui => {
                new TWEEN.Tween(ui.scale)
                    .to({ x: 0, y: 0, z: 0 }, 1000)
                    .easing(TWEEN.Easing.Cubic.In)
                    .onComplete(() => scene.remove(ui))
                    .start();
            });
            
            // Create logo assembly
            createLogoAssembly();
            
            // Show text overlays
            setTimeout(() => {
                document.getElementById('logo-text').classList.add('visible');
            }, 1000);
            
            setTimeout(() => {
                document.querySelector('.cta-button').classList.add('visible');
            }, 2000);
            
            // Create confetti
            setTimeout(createConfetti, 3000);
        }
        
        function createLogoAssembly() {
            const logoGroup = new THREE.Group();
            
            // Attract all particles to form logo
            particles.forEach((particle, index) => {
                if (particle.userData.isFlowParticle) {
                    const targetX = (Math.random() - 0.5) * 2;
                    const targetY = (Math.random() - 0.5) * 2;
                    const targetZ = 0;
                    
                    new TWEEN.Tween(particle.position)
                        .to({ x: targetX, y: targetY, z: targetZ }, 2000)
                        .easing(TWEEN.Easing.Cubic.InOut)
                        .delay(index * 5)
                        .start();
                    
                    new TWEEN.Tween(particle.material)
                        .to({ emissiveIntensity: 5 }, 2000)
                        .easing(TWEEN.Easing.Cubic.InOut)
                        .start();
                }
            });
            
            logo = logoGroup;
            scene.add(logo);
        }
        
        function createConfetti() {
            const confettiColors = [0xB5384D, 0xFFD700, 0x00D4FF, 0xFFFFFF];
            
            for (let i = 0; i < 100; i++) {
                const confettiGeometry = new THREE.PlaneGeometry(0.1, 0.2);
                const confettiMaterial = new THREE.MeshBasicMaterial({
                    color: confettiColors[Math.floor(Math.random() * confettiColors.length)],
                    side: THREE.DoubleSide
                });
                
                const confetti = new THREE.Mesh(confettiGeometry, confettiMaterial);
                confetti.position.set(
                    (Math.random() - 0.5) * 20,
                    Math.random() * 5 + 10,
                    (Math.random() - 0.5) * 10
                );
                
                confetti.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                
                confetti.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.1,
                    -Math.random() * 0.1 - 0.05,
                    (Math.random() - 0.5) * 0.1
                );
                
                confetti.userData.rotationSpeed = new THREE.Vector3(
                    Math.random() * 0.1,
                    Math.random() * 0.1,
                    Math.random() * 0.1
                );
                
                confetti.userData.isConfetti = true;
                particles.push(confetti);
                scene.add(confetti);
            }
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            currentTime += delta;
            
            // Update progress bar
            const progress = (currentTime / totalDuration) * 100;
            document.querySelector('.progress-fill').style.width = progress + '%';
            
            // Timeline control with flags to prevent repeated calls
            if (currentTime > 3 && !window.scene2Started) {
                window.scene2Started = true;
                startTransformation();
            } else if (currentTime > 7 && !window.scene3Started) {
                window.scene3Started = true;
                createNewWorld();
            } else if (currentTime > 11 && !window.scene4Started) {
                window.scene4Started = true;
                createFinalReveal();
            }
            
            // Update animations
            updateAnimations(delta);
            
            // Update camera
            updateCamera();
            
            // Update TWEEN
            TWEEN.update();
            
            // Render
            renderer.render(scene, camera);
            
            // Loop video
            if (currentTime > totalDuration && isPlaying) {
                currentTime = 0;
                window.scene2Started = false;
                window.scene3Started = false;
                window.scene4Started = false;
                location.reload(); // Simple reset
            }
        }
        
        function updateAnimations(delta) {
            // Animate queue people swaying
            queuePeople.forEach((person, index) => {
                person.rotation.z = Math.sin(currentTime + person.userData.offset) * 0.1;
            });
            
            // Animate clock
            if (officeClock) {
                officeClock.userData.hourHand.rotation.z = -currentTime * 2;
                officeClock.userData.minuteHand.rotation.z = -currentTime * 24;
            }
            
            // Animate particles
            particles.forEach((particle, index) => {
                if (particle.userData.velocity) {
                    particle.position.add(particle.userData.velocity);
                    if (particle.userData.rotationSpeed) {
                        particle.rotation.x += particle.userData.rotationSpeed.x;
                        particle.rotation.y += particle.userData.rotationSpeed.y;
                        particle.rotation.z += particle.userData.rotationSpeed.z;
                    }
                }
                
                // Digital rain
                if (particle.userData.isRain) {
                    particle.position.y -= particle.userData.velocity;
                    if (particle.position.y < -5) {
                        particle.position.y = 10;
                    }
                }
                
                // Flow particles
                if (particle.userData.isFlowParticle && currentTime < 11) {
                    particle.userData.angle += particle.userData.speed;
                    particle.position.x = Math.cos(particle.userData.angle) * particle.userData.radius;
                    particle.position.z = Math.sin(particle.userData.angle) * particle.userData.radius;
                }
                
                // Confetti
                if (particle.userData.isConfetti) {
                    particle.position.add(particle.userData.velocity);
                    particle.rotation.x += particle.userData.rotationSpeed.x;
                    particle.rotation.y += particle.userData.rotationSpeed.y;
                    particle.rotation.z += particle.userData.rotationSpeed.z;
                    
                    if (particle.position.y < -5) {
                        particle.position.y = 10;
                    }
                }
            });
            
            // Animate permit card
            if (permitCard) {
                permitCard.rotation.y += 0.005;
                permitCard.position.y = Math.sin(currentTime * 2) * 0.2;
                
                // Update holographic shader
                if (permitCard.userData.holoMaterial) {
                    permitCard.userData.holoMaterial.uniforms.time.value = currentTime;
                }
            }
            
            // Animate floating UI
            floatingUI.forEach((ui, index) => {
                ui.rotation.y += 0.01;
                ui.position.y = 1 + Math.sin(currentTime * 2 + index) * 0.3;
            });
        }
        
        function updateCamera() {
            // Scene 1: Dolly in
            if (currentTime < 3) {
                camera.position.x = THREE.MathUtils.lerp(0, -5, currentTime / 3);
                camera.position.y = THREE.MathUtils.lerp(5, 2, currentTime / 3);
                camera.position.z = THREE.MathUtils.lerp(10, 5, currentTime / 3);
                camera.lookAt(0, 0, 0);
            }
            // Scene 2: Orbit
            else if (currentTime >= 3 && currentTime < 7) {
                const t = (currentTime - 3) / 4;
                const angle = t * Math.PI * 2;
                camera.position.x = Math.cos(angle) * 8;
                camera.position.y = 3 + Math.sin(angle * 2) * 2;
                camera.position.z = Math.sin(angle) * 8;
                camera.lookAt(0, 0, 0);
            }
            // Scene 3: Fly through
            else if (currentTime >= 7 && currentTime < 11) {
                const t = (currentTime - 7) / 4;
                camera.position.x = Math.sin(t * Math.PI) * 6;
                camera.position.y = 2 + Math.cos(t * Math.PI * 2) * 2;
                camera.position.z = 8 - t * 3;
                camera.lookAt(permitCard.position);
            }
            // Scene 4: Pull back
            else if (currentTime >= 11) {
                const t = (currentTime - 11) / 4;
                camera.position.x = 0;
                camera.position.y = THREE.MathUtils.lerp(2, 0, t);
                camera.position.z = THREE.MathUtils.lerp(5, 8, t);
                camera.lookAt(0, 0, 0);
            }
        }
        
        function skipToEnd() {
            currentTime = 11;
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Initialize when loaded
        window.addEventListener('load', init);
    </script>
</body>
</html>